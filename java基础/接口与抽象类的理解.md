**参考：**

https://www.cnblogs.com/dolphin0520/p/3811437.html

https://www.jianshu.com/p/038f0b356e9a

https://blog.csdn.net/chenssy/article/details/12858267

### 一、抽象类

#### 1、含义

　　使用abstract修饰符修饰的类。一个类中含有抽象方法（被abstract修饰），那么这个类必须被声明为抽象类（被abstract修饰）。

**抽象方法：**

　　抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：

```java
abstract void fun();
```

　　抽象方法必须用**abstract**关键字进行修饰。**如果一个类含有抽象方法，则称这个类为抽象类**，抽象类必须在类前用abstract关键字修饰。**因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象**。

```java
[public] abstract class ClassName {
    abstract void fun();
}
```

#### 2、对于抽象类的理解

　　抽象类就是为了继承而存在，如果不对抽象类进行继承，则无法使用到该抽象类，因为其不能创建对象。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。

#### 3、抽象类和普通类的区别：

　　包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样**可以拥有成员变量和普通的成员方法**。注意，抽象类和普通类的主要有三点区别：

1. 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
2. 抽象类不能用来创建对象；
3. 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

　　在其他方面，抽象类和普通的类并没有区别。

### 二、接口（interface）

#### 1、含义

接口在java中是一个抽象类型，是抽象方法的集合。一个类通过继承接口的方式，从而继承接口的抽象方法。

#### 2、特点

* 接口中可以含有 变量和方法。但是要注意，接口中的**变量**会被隐式地指定为 public static final变量（**并且只能是public static final变量，用private修饰会报编译错误**）
* 而**方法**会被隐式地指定为public abstract方法且只能是**public abstract**方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）
* 接口中所有的方法不能有具体地实现，也就是说，接口中的方法必须是抽象方法。从这里可以隐式看出接口和抽象类的区别，它比抽象类更加“抽象”，并且**一般情况下不在接口中定义变量**
* 允许一个类遵循多个特定接口
* 如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法
* 对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法

要让一个类遵循某组特地的接口需要使用**implements**关键字，具体格式如下：

```java
class ClassName implements Interface1,Interface2,[....]{
}
```

### 三、抽象类和接口的区别

#### 1、语法层面上的区别

* 抽象类可以提供成员方法的实现细节；而接口中只能存在public abstract方法，不能存在方法的实现
* 抽象类中的成员变量可以是各种类型的；而接口中的成员变量只能是public static final类型的
* 抽象类中可以有静态代码块和静态方法；而接口中不能含有静态代码块和静态方法
* 一个类只能继承一个抽象类，但一个类却可以实现多个接口
* 抽象类可以有构造器（但是不能实例化），而接口不能有构造器
* 实现抽象类使用 **extends** 关键字来继承抽象类，如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现，但是如果子类没有全部实现抽象方法，就必须把自己也修饰成抽象类，交于继承它的子类来完成。而接口的实现，通过 **implements** 关键字来实现接口，它需要提供接口中所有声明的方法的实现（**即抽象类的子类可以不全部实现父类中声明的方法，但是实现接口的类一定要全部实现接口中声明的方法**）

#### 2、设计层面上的区别

* 抽象层面不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类**整体**进行抽象，包括属性、行为，但是接口却是对类**局部**（行为）进行抽象。
* 跨域不同。抽象类所跨域的是具有相同特点的类，而接口却可以跨域不同的类。 我们知道**抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处**。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"[is](http://www.mydown.com/soft/network/chat/475/444475.shtml)-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。
* 设计层次不同。对于抽象类而言，它是**自下而上**来设计的，我们**要先知道子类才能抽象出父类**；而接口不同，它根本就**不需要知道子类的存在**，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。所以说**抽象类是自底向上抽象而来的，接口是自顶向下设计出来的**。

**举例说明：**

门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：

抽象类：

```java
abstract class Door {
    public abstract void open();
    public abstract void close();
}
```

接口：

```java
interface Door {
    public abstract void open();
    public abstract void close();
}
```

　　但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：

　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；

　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。

　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。

```java
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

